<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jarvis Air-Writer 2.0</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

    <style>
        body, html { margin: 0; padding: 0; background: #000; overflow: hidden; font-family: 'Courier New', Courier, monospace; }
        
        /* Video Background */
        .input_video {
            position: fixed; width: 100%; height: 100%; object-fit: cover;
            transform: scaleX(-1); opacity: 0.5; z-index: 1;
        }

        /* Drawing Canvas */
        .output_canvas {
            position: fixed; width: 100%; height: 100%;
            z-index: 2; transform: scaleX(-1);
        }

        /* UI Overlay */
        #ui-layer {
            position: fixed; inset: 0; z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 30px;
        }

        /* Virtual Buttons Container */
        .controls {
            display: flex; justify-content: center; gap: 20px;
            pointer-events: auto; padding-bottom: 40px;
        }

        /* Button Styling */
        .v-btn {
            width: 60px; height: 60px; border-radius: 50%; 
            border: 3px solid rgba(255,255,255,0.3);
            cursor: pointer; transition: all 0.3s;
            display: flex; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.5);
        }

        .clear-btn { 
            width: auto; height: 60px; border-radius: 10px; padding: 0 20px;
            color: white; font-weight: bold; font-size: 0.8rem;
        }

        .active-tool { border: 4px solid #fff; transform: scale(1.2); box-shadow: 0 0 20px currentColor; }

        /* Initial Start Screen */
        #start-screen {
            position: fixed; inset: 0; background: rgba(0,10,20,0.95);
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; z-index: 100; color: #0ff;
        }
        .start-btn {
            padding: 25px 50px; font-size: 1.2rem; background: transparent;
            border: 2px solid #0ff; color: #0ff; cursor: pointer;
            box-shadow: 0 0 15px #0ff; letter-spacing: 3px;
        }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="font-size: 3rem; margin-bottom: 0;">J.A.R.V.I.S.</h1>
        <p style="margin-bottom: 40px; opacity: 0.7;">NEURAL INTERFACE READY</p>
        <button class="start-btn" onclick="initSystem()">INITIALIZE SYSTEM</button>
    </div>

    <video class="input_video" playsinline></video>
    <canvas class="output_canvas"></canvas>

    <div id="ui-layer">
        <div style="color: #0ff; text-shadow: 0 0 10px #0ff;">
            <h2 id="mode-text">MODE: AIR-WRITE</h2>
            <div id="status-bar">BRUSH: <span id="color-indicator">CYAN</span></div>
        </div>

        <div class="controls">
            <div id="btn-clear" class="v-btn clear-btn" onclick="clearCanvas()">CLEAR</div>
            <div id="btn-cyan" class="v-btn active-tool" style="background: #00ffff; color: #00ffff;" onclick="setColor('#00ffff', 'CYAN', this)"></div>
            <div id="btn-red" class="v-btn" style="background: #ff0055; color: #ff0055;" onclick="setColor('#ff0055', 'RED', this)"></div>
            <div id="btn-gold" class="v-btn" style="background: #ffcc00; color: #ffcc00;" onclick="setColor('#ffcc00', 'GOLD', this)"></div>
            <div id="btn-green" class="v-btn" style="background: #00ff44; color: #00ff44;" onclick="setColor('#00ff44', 'GREEN', this)"></div>
        </div>
    </div>

<script>
    const videoElement = document.querySelector('.input_video');
    const canvasElement = document.querySelector('.output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const colorIndicator = document.getElementById('color-indicator');

    let currentBrushColor = '#00ffff';
    let paths = []; 
    let currentPath = [];
    let isPinching = false;

    function initSystem() {
        document.getElementById('start-screen').style.display = 'none';
        camera.start();
    }

    function setColor(hex, name, el) {
        currentBrushColor = hex;
        colorIndicator.innerText = name;
        document.querySelectorAll('.v-btn').forEach(b => b.classList.remove('active-tool'));
        el.classList.add('active-tool');
    }

    function clearCanvas() {
        paths = [];
        currentPath = [];
    }

    // Logic to check if finger is hovering over a button
    function checkVirtualSelection(x, y) {
        const buttons = document.querySelectorAll('.v-btn');
        buttons.forEach(btn => {
            const rect = btn.getBoundingClientRect();
            // Since video is mirrored, we invert the X coordinate for collision
            const mirroredX = window.innerWidth - x; 

            if (mirroredX > rect.left && mirroredX < rect.right && y > rect.top && y < rect.bottom) {
                btn.style.boxShadow = `0 0 30px ${btn.style.color}`;
                if (isPinching) btn.click(); // Trigger the selection
            } else {
                btn.style.boxShadow = 'none';
            }
        });
    }

    function onResults(results) {
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const hand = results.multiHandLandmarks[0];
            const indexTip = hand[8];
            const thumbTip = hand[4];

            // Convert normalized coordinates to screen pixels
            const screenX = indexTip.x * canvasElement.width;
            const screenY = indexTip.y * canvasElement.height;

            // 1. Detect Pinch
            const dist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
            isPinching = (dist < 0.05);

            // 2. Check for Air Button Selection
            checkVirtualSelection(screenX, screenY);

            // 3. Drawing Logic (Only if NOT over a button)
            if (isPinching && screenY < canvasElement.height - 150) {
                currentPath.push({ x: screenX, y: screenY });
            } else if (!isPinching && currentPath.length > 0) {
                paths.push({ points: [...currentPath], color: currentBrushColor });
                currentPath = [];
            }

            // Draw Hand Skeleton
            drawConnectors(canvasCtx, hand, HAND_CONNECTIONS, {color: '#ffffff22', lineWidth: 1});
            
            // Draw Cursor
            canvasCtx.beginPath();
            canvasCtx.arc(screenX, screenY, isPinching ? 15 : 10, 0, 2 * Math.PI);
            canvasCtx.strokeStyle = isPinching ? '#fff' : currentBrushColor;
            canvasCtx.lineWidth = 3;
            canvasCtx.stroke();
        }

        // Render all lines
        [...paths, {points: currentPath, color: currentBrushColor}].forEach(path => {
            if (path.points.length < 2) return;
            canvasCtx.beginPath();
            canvasCtx.strokeStyle = path.color;
            canvasCtx.lineWidth = 6;
            canvasCtx.lineCap = 'round';
            path.points.forEach((p, i) => {
                if (i === 0) canvasCtx.moveTo(p.x, p.y);
                else canvasCtx.lineTo(p.x, p.y);
            });
            canvasCtx.stroke();
        });

        canvasCtx.restore();
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 1280, height: 720
    });

    window.addEventListener('resize', () => {
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
    });
    canvasElement.width = window.innerWidth;
    canvasElement.height = window.innerHeight;

</script>
</body>
</html>
