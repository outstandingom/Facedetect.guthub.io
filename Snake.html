<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snow Snake Game</title>
    <style>
        body {
            background-color: #0f172a; /* Dark night sky color */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            overflow: hidden; /* Stop scrolling on mobile */
            touch-action: none; /* Stop zooming on mobile */
        }

        h1 {
            margin: 0 0 10px 0;
            text-shadow: 0 0 10px #ffffff;
            font-size: 24px;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border: 4px solid #334155;
            border-radius: 8px;
        }

        canvas {
            display: block;
            background-color: #1e293b;
            cursor: crosshair; /* Shows user they can interact */
            touch-action: none; /* Critical for mobile play */
        }

        #scoreBoard {
            font-size: 20px;
            margin-bottom: 10px;
        }

        #gameOverScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            text-align: center;
            border-radius: 10px;
            display: none;
            width: 80%;
        }

        button {
            background-color: #38bdf8;
            border: none;
            padding: 12px 24px;
            color: #0f172a;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 15px;
        }

        button:hover {
            background-color: #7dd3fc;
        }
        
        .instructions {
            margin-top: 10px;
            font-size: 12px;
            color: #94a3b8;
        }
    </style>
</head>
<body>

    <h1>Snow Snake â„ï¸</h1>
    <div id="scoreBoard">Score: 0</div>

    <div id="gameContainer">
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        <div id="gameOverScreen">
            <h2>Game Over!</h2>
            <p>You hit yourself!</p>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button onclick="resetGame()">Play Again</button>
        </div>
    </div>
    <div class="instructions">Use Arrow Keys, Mouse, or Touch to move</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('scoreBoard');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreElement = document.getElementById('finalScore');

        // Game settings
        const gridSize = 20; 
        const tileCount = canvas.width / gridSize;
        let speed = 7; 

        // The user's specific food list
        const foodEmojis = [..."ğŸ‚ğŸ¼ğŸ§ ğŸ†ğŸ‘ğŸ‘½ğŸ‘ºğŸ’©ğŸ’˜ğŸ¦¾ğŸ§–â˜˜ï¸ğŸª´ğŸŒ‹ğŸ¦ğŸ¦–ğŸ¦•ğŸ¦ğŸğŸ•â€ğŸ¦ºğŸğŸ•ğŸ€ğŸ‘ğŸ€ğŸ©ğŸğŸ•ğŸ˜ğŸ¦¦ğŸ¦›ğŸ’ğŸ¦ŒğŸ¦¦ğŸª°ğŸ¥ğŸ¥¯ğŸ¥£ğŸŒ­ğŸ¥ªğŸ¥£ğŸšğŸ¥¨ğŸ¤ğŸ¥¨ğŸ±ğŸ¥–ğŸ§€ğŸšğŸ¥˜ğŸ¥£ğŸ›ğŸ¥ğŸ¥¬ğŸˆğŸ¥ğŸˆğŸ«‘ğŸğŸ¥ª"];

        // Game variables
        let score = 0;
        let velocityX = 0;
        let velocityY = 0;
        let headX = 10;
        let headY = 10;
        let snakeParts = [];
        let tailLength = 2;
        
        let foodX = 5;
        let foodY = 5;
        let currentFoodEmoji = "ğŸ";
        let gameRunning = true;

        // Start the game loop
        function drawGame() {
            if (!gameRunning) return;

            changeSnakePosition();
            
            let result = isGameOver();
            if (result) {
                gameRunning = false;
                showGameOver();
                return;
            }

            clearScreen();
            checkFoodCollision();
            drawFood();
            drawSnake();
            
            setTimeout(drawGame, 1000 / speed);
        }

        function isGameOver() {
            let gameOver = false;
            if (velocityX === 0 && velocityY === 0) return false;

            // Walls
            if (headX < 0 || headX === tileCount || headY < 0 || headY === tileCount) {
                gameOver = true;
            }

            // Body
            for (let i = 0; i < snakeParts.length; i++) {
                let part = snakeParts[i];
                if (part.x === headX && part.y === headY) {
                    gameOver = true;
                    break;
                }
            }
            return gameOver;
        }

        function showGameOver() {
            finalScoreElement.innerText = score;
            gameOverScreen.style.display = "block";
        }

        function resetGame() {
            score = 0;
            scoreElement.innerText = "Score: " + score;
            velocityX = 0;
            velocityY = 0;
            headX = 10;
            headY = 10;
            snakeParts = [];
            tailLength = 2;
            speed = 7;
            gameRunning = true;
            gameOverScreen.style.display = "none";
            pickNewFood();
            drawGame();
        }

        function clearScreen() {
            ctx.fillStyle = '#1e293b'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawSnake() {
            ctx.fillStyle = "white"; 
            for (let i = 0; i < snakeParts.length; i++) {
                let part = snakeParts[i];
                ctx.beginPath();
                ctx.arc(part.x * gridSize + gridSize/2, part.y * gridSize + gridSize/2, gridSize/2 - 2, 0, Math.PI * 2);
                ctx.fill();
            }

            snakeParts.push(new SnakePart(headX, headY)); 
            while (snakeParts.length > tailLength) {
                snakeParts.shift(); 
            }

            ctx.fillStyle = "#e2e8f0"; 
            ctx.beginPath();
            ctx.arc(headX * gridSize + gridSize/2, headY * gridSize + gridSize/2, gridSize/2 - 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "black";
            ctx.beginPath();
            // Eyes direction logic
            let eyeOffsetX = 0;
            let eyeOffsetY = 0;
            if(velocityX === 1) eyeOffsetX = 4;
            if(velocityX === -1) eyeOffsetX = -4;
            if(velocityY === 1) eyeOffsetY = 4;
            if(velocityY === -1) eyeOffsetY = -4;

            ctx.arc(headX * gridSize + gridSize/2 - 2 + eyeOffsetX, headY * gridSize + gridSize/2 - 2 + eyeOffsetY, 2, 0, Math.PI * 2);
            ctx.arc(headX * gridSize + gridSize/2 + 2 + eyeOffsetX, headY * gridSize + gridSize/2 - 2 + eyeOffsetY, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        function changeSnakePosition() {
            headX = headX + velocityX;
            headY = headY + velocityY;
        }

        function drawFood() {
            ctx.font = "20px Arial";
            ctx.fillText(currentFoodEmoji, foodX * gridSize - 2, foodY * gridSize + gridSize - 2);
        }

        function checkFoodCollision() {
            if (foodX === headX && foodY === headY) {
                pickNewFood();
                score++;
                scoreElement.innerText = "Score: " + score;
                tailLength++;
                if(score % 5 === 0) speed += 1;
            }
        }

        function pickNewFood() {
            foodX = Math.floor(Math.random() * tileCount);
            foodY = Math.floor(Math.random() * tileCount);
            const randomIndex = Math.floor(Math.random() * foodEmojis.length);
            currentFoodEmoji = foodEmojis[randomIndex];
            for (let part of snakeParts) {
                if (part.x === foodX && part.y === foodY) pickNewFood();
            }
        }

        class SnakePart {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
        }

        // --- CONTROLS ---

        // 1. Keyboard Controls
        document.body.addEventListener('keydown', keyDown);

        function keyDown(event) {
            if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(event.code) > -1) {
                event.preventDefault();
            }
            if (event.keyCode == 38) { if (velocityY == 1) return; velocityY = -1; velocityX = 0; }
            if (event.keyCode == 40) { if (velocityY == -1) return; velocityY = 1; velocityX = 0; }
            if (event.keyCode == 37) { if (velocityX == 1) return; velocityY = 0; velocityX = -1; }
            if (event.keyCode == 39) { if (velocityX == -1) return; velocityY = 0; velocityX = 1; }
        }

        // 2. Mouse & Touch Controls
        canvas.addEventListener('mousemove', handleInput);
        canvas.addEventListener('touchmove', handleInput, {passive: false});
        canvas.addEventListener('touchstart', handleInput, {passive: false});

        function handleInput(e) {
            // Only control if game is running
            if(!gameRunning) return;

            // Prevent scrolling on mobile
            if(e.type === 'touchmove' || e.type === 'touchstart') {
                e.preventDefault();
            }

            // Get pointer position (Mouse or Touch)
            let clientX, clientY;
            if(e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            // Get canvas position
            const rect = canvas.getBoundingClientRect();
            const relativeX = clientX - rect.left;
            const relativeY = clientY - rect.top;

            // Snake Head position in pixels
            const snakePixelX = headX * gridSize + gridSize / 2;
            const snakePixelY = headY * gridSize + gridSize / 2;

            // Calculate distance
            const dx = relativeX - snakePixelX;
            const dy = relativeY - snakePixelY;

            // Determine if horizontal or vertical distance is greater
            if (Math.abs(dx) > Math.abs(dy)) {
                // Move Horizontally
                if (dx > 0) {
                    if (velocityX == -1) return; // Don't crash into self
                    velocityY = 0;
                    velocityX = 1;
                } else {
                    if (velocityX == 1) return;
                    velocityY = 0;
                    velocityX = -1;
                }
            } else {
                // Move Vertically
                if (dy > 0) {
                    if (velocityY == -1) return;
                    velocityY = 1;
                    velocityX = 0;
                } else {
                    if (velocityY == 1) return;
                    velocityY = -1;
                    velocityX = 0;
                }
            }
        }

        // Init
        pickNewFood();
        drawGame();

    </script>
</body>
</html>
